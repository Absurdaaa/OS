# Lab3 扩展练习：中断流程与上下文切换分析报告

## 扩展练习 Challenge1：描述与理解中断流程

### 一、uCore中处理中断异常的完整流程

#### 1.1 异常/中断的产生（硬件层面）

当发生异常或中断时（如时钟中断、缺页异常、系统调用等），RISC-V硬件自动完成以下操作：

**硬件自动保存的状态：**

```c
// 以下是硬件自动完成的操作（不需要软件干预）
scause   ← 异常/中断原因码
           // 最高位=1: 中断（如 0x8000000000000005 = S模式时钟中断）
           // 最高位=0: 异常（如 0x0000000000000008 = 系统调用）

sepc     ← 异常发生时的PC
           // 对于中断：指向被中断的指令
           // 对于异常：指向引发异常的指令

sbadaddr ← 引发异常的地址（如缺页时的虚拟地址）

sstatus  ← 状态位更新：
           // SPIE ← SIE（保存中断使能位）
           // SIE ← 0（关闭中断，防止嵌套）
           // SPP ← 发生异常前的特权级（0=用户态，1=内核态）

PC       ← stvec（跳转到异常处理入口 __alltraps）
```

**关键点：** 硬件只保存了**3个CSR寄存器**和**状态位**，**没有保存通用寄存器**，这需要软件来完成。

#### 1.2 进入__alltraps（软件保存现场）

当硬件跳转到`__alltraps`后，首先需要保存完整的CPU上下文。

**代码位置：** `kern/trap/trapentry.S`

```asm
    .globl __alltraps
    .align(2)
__alltraps:
    SAVE_ALL                   // 保存完整的CPU上下文（所有寄存器）
    move  a0, sp               // 将trapframe指针传给trap函数作为第一个参数
    jal trap                   // 跳转到C函数trap()处理异常
```

#### 1.3 SAVE_ALL宏的详细实现

```asm
.macro SAVE_ALL
    // 步骤1: 先将当前sp暂存到sscratch，以便保存原始sp值
    csrw sscratch, sp

    // 步骤2: 在当前栈上为36个寄存器分配空间
    // （32个通用寄存器 + 4个异常相关CSR寄存器）
    addi sp, sp, -36 * REGBYTES

    // 步骤3: 依次保存所有通用寄存器（x0~x31）
    STORE x0, 0*REGBYTES(sp)     // zero寄存器
    STORE x1, 1*REGBYTES(sp)     // ra: 返回地址
    STORE x3, 3*REGBYTES(sp)     // gp: 全局指针
    STORE x4, 4*REGBYTES(sp)     // tp: 线程指针
    STORE x5, 5*REGBYTES(sp)     // t0-t2: 临时寄存器
    STORE x6, 6*REGBYTES(sp)
    STORE x7, 7*REGBYTES(sp)
    STORE x8, 8*REGBYTES(sp)     // s0/fp: 保存寄存器/帧指针
    STORE x9, 9*REGBYTES(sp)     // s1: 保存寄存器
    STORE x10, 10*REGBYTES(sp)   // a0-a7: 函数参数/返回值
    STORE x11, 11*REGBYTES(sp)
    STORE x12, 12*REGBYTES(sp)
    STORE x13, 13*REGBYTES(sp)
    STORE x14, 14*REGBYTES(sp)
    STORE x15, 15*REGBYTES(sp)
    STORE x16, 16*REGBYTES(sp)
    STORE x17, 17*REGBYTES(sp)
    STORE x18, 18*REGBYTES(sp)   // s2-s11: 保存寄存器
    STORE x19, 19*REGBYTES(sp)
    STORE x20, 20*REGBYTES(sp)
    STORE x21, 21*REGBYTES(sp)
    STORE x22, 22*REGBYTES(sp)
    STORE x23, 23*REGBYTES(sp)
    STORE x24, 24*REGBYTES(sp)
    STORE x25, 25*REGBYTES(sp)
    STORE x26, 26*REGBYTES(sp)
    STORE x27, 27*REGBYTES(sp)
    STORE x28, 28*REGBYTES(sp)   // t3-t6: 临时寄存器
    STORE x29, 29*REGBYTES(sp)
    STORE x30, 30*REGBYTES(sp)
    STORE x31, 31*REGBYTES(sp)

    // 步骤4: 读取并保存异常相关的CSR寄存器
    csrrw s0, sscratch, x0       // 从sscratch读取原始sp，同时清零sscratch
    csrr s1, sstatus             // 读取异常前的状态
    csrr s2, sepc                // 读取异常返回地址
    csrr s3, sbadaddr            // 读取触发异常的地址
    csrr s4, scause              // 读取异常原因码

    // 步骤5: 将上述CSR寄存器值保存到栈的对应位置
    STORE s0, 2*REGBYTES(sp)     // 保存原始sp
    STORE s1, 32*REGBYTES(sp)    // 保存sstatus
    STORE s2, 33*REGBYTES(sp)    // 保存sepc
    STORE s3, 34*REGBYTES(sp)    // 保存sbadaddr
    STORE s4, 35*REGBYTES(sp)    // 保存scause
.endm
```

**保存后的栈布局（trapframe结构）：**

```
高地址
+------------------+
| scause     (35)  | ← 异常原因码
| sbadaddr   (34)  | ← 异常地址
| sepc       (33)  | ← 异常发生时的PC
| sstatus    (32)  | ← 状态寄存器
| x31/t6     (31)  |
| x30/t5     (30)  |
| ...              |
| x10/a0     (10)  | ← 函数参数/返回值
| ...              |
| x3/gp      (3)   |
| x2/sp      (2)   | ← 原始栈指针
| x1/ra      (1)   | ← 返回地址
| x0/zero    (0)   |
+------------------+ ← 当前sp指向这里（trapframe起始地址）
低地址
```

#### 1.4 调用C函数trap()进行分发处理

**代码位置：** `kern/trap/trap.c`

```c
void trap(struct trapframe *tf) {
    // 根据异常类型分发处理
    trap_dispatch(tf);
}

static inline void trap_dispatch(struct trapframe *tf) {
    if ((intptr_t)tf->cause < 0) {
        // cause最高位=1，是中断
        interrupt_handler(tf);
    } else {
        // cause最高位=0，是异常
        exception_handler(tf);
    }
}
```

**中断处理函数：**

```c
void interrupt_handler(struct trapframe *tf) {
    intptr_t cause = (tf->cause << 1) >> 1;  // 去掉最高位
    switch (cause) {
        case IRQ_S_TIMER:  // Supervisor定时器中断
            clock_set_next_event();  // 设置下次时钟中断
            if (++ticks % TICK_NUM == 0) {
                print_num++;
                print_ticks();
            }
            if (print_num == 10) {
                sbi_shutdown();
            }
            break;
        case IRQ_S_SOFT:
            cprintf("Supervisor software interrupt\n");
            break;
        // ... 其他中断类型 ...
        default:
            print_trapframe(tf);
            break;
    }
}
```

**异常处理函数：**

```c
void exception_handler(struct trapframe *tf) {
    switch (tf->cause) {
        case CAUSE_ILLEGAL_INSTRUCTION:  // 非法指令
            cprintf("Exception type: Illegal instruction\n");
            cprintf("Illegal instruction caught at 0x%016llx\n", tf->epc);
            tf->epc += 4;  // 跳过非法指令
            break;
        case CAUSE_BREAKPOINT:  // 断点异常
            cprintf("Exception type: breakpoint\n");
            cprintf("ebreak caught at 0x%016llx\n", tf->epc);
            tf->epc += 2;  // ebreak是2字节指令
            break;
        // ... 其他异常类型 ...
        default:
            print_trapframe(tf);
            break;
    }
}
```

#### 1.5 恢复现场并返回

**RESTORE_ALL宏的实现：**

```asm
.macro RESTORE_ALL
    // 步骤1: 先恢复异常返回需要的关键CSR寄存器
    LOAD s1, 32*REGBYTES(sp)    // 从栈读取保存的sstatus
    LOAD s2, 33*REGBYTES(sp)    // 从栈读取保存的sepc

    csrw sstatus, s1            // 恢复sstatus
    csrw sepc, s2               // 恢复sepc（sret将跳转到这个地址）

    // 步骤2: 恢复所有通用寄存器（x1~x31）
    LOAD x1, 1*REGBYTES(sp)     // ra: 返回地址
    LOAD x3, 3*REGBYTES(sp)
    // ... 恢复x4-x31 ...
    LOAD x31, 31*REGBYTES(sp)
    
    // 步骤3: 最后恢复sp（栈指针）
    LOAD x2, 2*REGBYTES(sp)
.endm
```

**异常返回：**

```asm
__trapret:
    RESTORE_ALL                // 恢复CPU上下文
    sret                       // 异常返回指令
```

**sret指令（硬件自动）：**
```
1. PC ← sepc（返回到异常发生点或下一条指令）
2. sstatus.SIE ← sstatus.SPIE（恢复中断使能位）
3. 恢复特权级：根据sstatus.SPP恢复到用户态或内核态
4. 继续执行被中断的程序
```

---

### 二、`move a0, sp` 的目的

#### 2.1 答案

**`move a0, sp` 的目的是：将trapframe结构的地址作为参数传递给C函数trap()**

#### 2.2 详细解释

**（1）RISC-V函数调用约定：**
- `a0`寄存器（x10）用于传递函数的第一个参数
- C函数`trap()`的签名是：`void trap(struct trapframe *tf)`
- 需要传递一个指向trapframe结构的指针

**（2）此时sp指向什么：**
- 执行完`SAVE_ALL`后，`sp`指向刚刚保存的trapframe结构的起始地址
- trapframe结构在栈上的布局与`struct trapframe`定义完全对应

**（3）move a0, sp 的作用：**
```asm
move a0, sp    // 等价于 addi a0, sp, 0
               // 将sp的值复制到a0
               // 现在a0指向trapframe结构的起始地址
```

**（4）在C函数中的使用：**

```c
void trap(struct trapframe *tf) {
    // tf指向栈上的trapframe结构
    // 可以访问所有保存的寄存器：
    cprintf("cause: %x\n", tf->cause);      // 异常原因
    cprintf("epc: %x\n", tf->epc);          // 异常发生地址
    cprintf("a0: %x\n", tf->gpr.a0);        // 通用寄存器a0的值
    
    // 甚至可以修改寄存器的值：
    tf->epc += 4;  // 跳过当前指令（处理断点/非法指令时常用）
    tf->gpr.a0 = 0;  // 修改返回值
}
```

#### 2.3 为什么这样设计？

1. **灵活性**：C函数可以检查和修改任何寄存器的值
2. **可移植性**：统一的数据结构便于不同架构移植
3. **调试友好**：可以方便地打印所有寄存器状态（`print_trapframe`）
4. **支持复杂操作**：
   - 系统调用可以读取参数（从a0-a7）
   - 可以设置返回值（修改a0）
   - 可以实现特殊的异常处理（如跳过非法指令）

---

### 三、SAVE_ALL中寄存器保存在栈中的位置是什么确定的？

#### 3.1 答案

**寄存器保存的位置由trapframe结构体的定义和REGBYTES常量共同确定。**

#### 3.2 trapframe结构体的定义

**代码位置：** `kern/trap/trap.h`

```c
// pushregs结构体保存所有通用寄存器
struct pushregs {
    uintptr_t zero;  // 偏移量: 0*REGBYTES
    uintptr_t ra;    // 偏移量: 1*REGBYTES
    uintptr_t sp;    // 偏移量: 2*REGBYTES
    uintptr_t gp;    // 偏移量: 3*REGBYTES
    uintptr_t tp;    // 偏移量: 4*REGBYTES
    uintptr_t t0;    // 偏移量: 5*REGBYTES
    uintptr_t t1;    // 偏移量: 6*REGBYTES
    uintptr_t t2;    // 偏移量: 7*REGBYTES
    uintptr_t s0;    // 偏移量: 8*REGBYTES
    uintptr_t s1;    // 偏移量: 9*REGBYTES
    uintptr_t a0;    // 偏移量: 10*REGBYTES
    uintptr_t a1;    // 偏移量: 11*REGBYTES
    uintptr_t a2;    // 偏移量: 12*REGBYTES
    uintptr_t a3;    // 偏移量: 13*REGBYTES
    uintptr_t a4;    // 偏移量: 14*REGBYTES
    uintptr_t a5;    // 偏移量: 15*REGBYTES
    uintptr_t a6;    // 偏移量: 16*REGBYTES
    uintptr_t a7;    // 偏移量: 17*REGBYTES
    uintptr_t s2;    // 偏移量: 18*REGBYTES
    uintptr_t s3;    // 偏移量: 19*REGBYTES
    uintptr_t s4;    // 偏移量: 20*REGBYTES
    uintptr_t s5;    // 偏移量: 21*REGBYTES
    uintptr_t s6;    // 偏移量: 22*REGBYTES
    uintptr_t s7;    // 偏移量: 23*REGBYTES
    uintptr_t s8;    // 偏移量: 24*REGBYTES
    uintptr_t s9;    // 偏移量: 25*REGBYTES
    uintptr_t s10;   // 偏移量: 26*REGBYTES
    uintptr_t s11;   // 偏移量: 27*REGBYTES
    uintptr_t t3;    // 偏移量: 28*REGBYTES
    uintptr_t t4;    // 偏移量: 29*REGBYTES
    uintptr_t t5;    // 偏移量: 30*REGBYTES
    uintptr_t t6;    // 偏移量: 31*REGBYTES
};

// trapframe结构体保存完整的异常现场
struct trapframe {
    struct pushregs gpr;   // 偏移量: 0-31*REGBYTES
    uintptr_t status;      // 偏移量: 32*REGBYTES
    uintptr_t epc;         // 偏移量: 33*REGBYTES
    uintptr_t badvaddr;    // 偏移量: 34*REGBYTES
    uintptr_t cause;       // 偏移量: 35*REGBYTES
};
```

#### 3.3 REGBYTES常量的定义

**代码位置：** `libs/riscv.h`

```c
#if __riscv_xlen == 64
# define LOG_REGBYTES 3        // 2^3 = 8
#else
# define LOG_REGBYTES 2        // 2^2 = 4
#endif
#define REGBYTES (1 << LOG_REGBYTES)
```

- **64位RISC-V**：`REGBYTES = 8`（每个寄存器8字节）
- **32位RISC-V**：`REGBYTES = 4`（每个寄存器4字节）

#### 3.4 汇编代码与C结构体的对应关系

```
C语言访问方式              汇编访问方式              内存偏移量（64位）
-----------------         ------------------        ------------------
tf->gpr.zero      ←→     0*REGBYTES(sp)     ←→     sp+0
tf->gpr.ra        ←→     1*REGBYTES(sp)     ←→     sp+8
tf->gpr.sp        ←→     2*REGBYTES(sp)     ←→     sp+16
tf->gpr.gp        ←→     3*REGBYTES(sp)     ←→     sp+24
...
tf->gpr.a0        ←→     10*REGBYTES(sp)    ←→     sp+80
...
tf->gpr.t6        ←→     31*REGBYTES(sp)    ←→     sp+248
tf->status        ←→     32*REGBYTES(sp)    ←→     sp+256
tf->epc           ←→     33*REGBYTES(sp)    ←→     sp+264
tf->badvaddr      ←→     34*REGBYTES(sp)    ←→     sp+272
tf->cause         ←→     35*REGBYTES(sp)    ←→     sp+280
```

#### 3.5 设计原则：汇编与C完全对应

**好处：**

1. **类型安全**：
   - C代码通过结构体访问，编译器自动计算偏移量
   - 避免手动计算偏移导致的错误

2. **一致性保证**：
   ```c
   // 汇编保存：STORE x10, 10*REGBYTES(sp)
   // C语言访问：tf->gpr.a0
   // 两者访问的是同一块内存！
   ```

3. **可维护性**：
   - 只需修改结构体定义
   - 汇编和C自动保持一致

4. **架构适应性**：
   - 通过REGBYTES自动适配32位/64位
   - 移植到不同架构只需修改REGBYTES定义

#### 3.6 验证对应关系

```c
// 可以用sizeof验证总大小：
sizeof(struct trapframe) == 36 * REGBYTES  // 在64位下 = 288字节

// 可以用offsetof验证特定字段的偏移量：
#include <stddef.h>
offsetof(struct trapframe, gpr.ra) == 1 * REGBYTES    // 8字节
offsetof(struct trapframe, gpr.a0) == 10 * REGBYTES   // 80字节
offsetof(struct trapframe, epc) == 33 * REGBYTES      // 264字节
offsetof(struct trapframe, cause) == 35 * REGBYTES    // 280字节
```

---

### 四、对于任何中断，__alltraps中都需要保存所有寄存器吗？

#### 4.1 答案

**是的，必须保存所有寄存器。**

#### 4.2 理由详解

##### （1）不确定性 - 无法预知哪些寄存器会被使用

中断处理函数可能调用任意C函数，而C编译器可能使用任何寄存器：

```c
void interrupt_handler(struct trapframe *tf) {
    switch (tf->cause) {
        case IRQ_S_TIMER:
            clock_set_next_event();     // 可能用到t0-t6
            cprintf("%d ticks\n", TICK_NUM);  // 可能用到a0-a7
            if (++ticks % TICK_NUM == 0) {
                print_ticks();          // 可能用到s0-s11
                // 调用栈可能很深：
                // print_ticks → cprintf → vprintfmt → putch → cons_putc
            }
            break;
    }
}
```

**问题：**
- C编译器可能使用任何caller-saved寄存器（t0-t6, a0-a7）
- 被调用的函数可能使用任何callee-saved寄存器（s0-s11）
- **无法提前预测具体使用哪些寄存器**

##### （2）透明性 - 中断处理必须对被中断代码透明

中断可能发生在任何时刻，被中断的代码可能正在使用所有寄存器：

```c
// 用户代码（或内核代码）正在执行
void some_function() {
    int a = x;      // 值在 a0 寄存器中
    int b = y;      // 值在 a1 寄存器中
    int c = z;      // 值在 a2 寄存器中
    
    // 临时计算，使用t0-t6
    int temp1 = a + b;  // 使用 t0
    int temp2 = b * c;  // 使用 t1
    
    // [时钟中断在这里发生！]
    // 如果中断处理不保存这些寄存器，它们的值会被破坏！
    
    result = temp1 + temp2;  // 错误！t0和t1已被破坏
}
```

**原则：** 中断处理后，被中断的代码必须**完全感知不到中断的发生**。

##### （3）嵌套调用 - C函数调用链未知

中断处理可能触发深层次的函数调用：

```
interrupt_handler() 
  → clock_set_next_event()
    → sbi_set_timer()
      → ecall (系统调用)
  → cprintf()
    → vprintfmt()
      → putch()
        → cons_putc()
          → serial_putc()
```

每一层调用都可能使用不同的寄存器，**必须全部保护**。

##### （4）异常信息完整性 - 调试和错误处理需要

在异常处理中，可能需要检查任何寄存器的值：

```c
void exception_handler(struct trapframe *tf) {
    // 打印完整的寄存器状态用于调试
    print_trapframe(tf);
    
    // 可能需要检查任何寄存器：
    if (tf->gpr.sp < KERNBASE || tf->gpr.sp >= KERNTOP) {
        panic("Invalid stack pointer: %p", tf->gpr.sp);
    }
    
    // 系统调用需要读取所有参数寄存器：
    switch (tf->cause) {
        case CAUSE_USER_ECALL:
            int syscall_no = tf->gpr.a7;  // 系统调用号
            void *arg0 = tf->gpr.a0;      // 参数1
            void *arg1 = tf->gpr.a1;      // 参数2
            // ... 可能需要a0-a7的所有参数
            break;
    }
}
```

##### （5）RISC-V的特殊性

与x86不同，RISC-V硬件在异常时**只保存3个CSR寄存器**：
- `sepc`：异常发生的PC
- `scause`：异常原因
- `sbadaddr`：异常地址

**硬件不保存通用寄存器**，所以软件必须保存所有32个通用寄存器。

#### 4.3 性能考虑

**问题：保存所有寄存器会不会影响性能？**

**回答：**
- 是的，有性能开销（36次存储操作 ≈ 36 × 8 = 288字节）
- 但**正确性优先于性能**
- 现代处理器的存储速度很快，开销可接受

**实测数据（估算）：**
- 保存36个寄存器：约36个Store指令
- 在现代CPU上：约36-72个时钟周期
- 对于1GHz CPU：约36-72纳秒
- 相比中断处理的整体开销（微秒级），这是可接受的

#### 4.4 可能的优化（不推荐用于通用OS）

某些**特殊的实时系统**可能只保存部分寄存器：

```asm
// 极简的快速中断处理（仅用于特定硬件确认）
fast_interrupt_handler:
    // 只保存会用到的几个寄存器
    addi sp, sp, -16
    sd t0, 0(sp)
    sd t1, 8(sp)
    
    // 简单的硬件操作（不调用任何函数）
    li t0, IRQ_ACK_ADDR
    li t1, 1
    sw t1, 0(t0)
    
    // 恢复
    ld t0, 0(sp)
    ld t1, 8(sp)
    addi sp, sp, 16
    sret
```

**但uCore不能这样做，因为：**
1. 中断处理逻辑复杂，无法预测寄存器使用
2. 调用C函数后无法保证寄存器安全
3. 统一的处理流程更易维护和调试
4. 通用操作系统需要支持各种复杂场景

#### 4.5 对比其他操作系统

| 操作系统 | 是否保存所有寄存器 | 说明 |
|---------|------------------|------|
| Linux   | 是 | 保存在pt_regs结构中 |
| xv6-riscv | 是 | 保存在trapframe中 |
| FreeRTOS | 是 | 任务上下文切换需要 |
| uCore | 是 | 保存在trapframe中 |

**结论：** 保存所有寄存器是**通用操作系统的标准做法**。

---

## 扩展练习 Challenge2：理解上下文切换机制

### 一、`csrw sscratch, sp` 和 `csrrw s0, sscratch, x0` 实现的操作和目的

#### 1.1 这两条指令的作用

**指令1：`csrw sscratch, sp`**

```asm
csrw sscratch, sp    // CSR Write: sscratch ← sp
```

**作用：** 将当前栈指针`sp`的值保存到`sscratch`寄存器中。

**指令2：`csrrw s0, sscratch, x0`**

```asm
csrrw s0, sscratch, x0    // CSR Read-Write: 
                          // s0 ← sscratch
                          // sscratch ← x0 (即 sscratch ← 0)
```

**作用：** 
- 将`sscratch`的值（即原始的`sp`）读取到`s0`寄存器
- 同时将`sscratch`清零（写入x0的值，即0）

#### 1.2 完整的上下文保存流程

让我们看看SAVE_ALL中这两条指令的完整上下文：

```asm
.macro SAVE_ALL
    // [步骤1] 保存原始sp到sscratch
    csrw sscratch, sp           // sscratch ← sp（异常发生时的栈指针）

    // [步骤2] 调整栈指针，分配trapframe空间
    addi sp, sp, -36 * REGBYTES // sp ← sp - 288（为36个寄存器分配空间）

    // [步骤3] 保存所有通用寄存器到新的栈空间
    STORE x0, 0*REGBYTES(sp)
    STORE x1, 1*REGBYTES(sp)
    // 注意：x2(sp)的位置先空着，因为我们要保存的是原始sp，不是调整后的
    STORE x3, 3*REGBYTES(sp)
    // ... 保存x4-x31 ...
    STORE x31, 31*REGBYTES(sp)

    // [步骤4] 从sscratch取回原始sp，并清零sscratch
    csrrw s0, sscratch, x0      // s0 ← sscratch（原始sp）
                                // sscratch ← 0（清零，标识在内核态）

    // [步骤5] 读取其他CSR寄存器
    csrr s1, sstatus
    csrr s2, sepc
    csrr s3, sbadaddr
    csrr s4, scause

    // [步骤6] 保存CSR寄存器（包括原始sp）到栈
    STORE s0, 2*REGBYTES(sp)    // 保存原始sp到正确位置
    STORE s1, 32*REGBYTES(sp)   // 保存sstatus
    STORE s2, 33*REGBYTES(sp)   // 保存sepc
    STORE s3, 34*REGBYTES(sp)   // 保存sbadaddr
    STORE s4, 35*REGBYTES(sp)   // 保存scause
.endm
```

#### 1.3 为什么需要这两条指令？

**问题：** 为什么不能直接保存sp？

**错误的方式：**
```asm
// 错误示例！
addi sp, sp, -36 * REGBYTES
STORE sp, 2*REGBYTES(sp)    // 保存的是调整后的sp，不是原始sp！
```

这样会保存**调整后的sp**，而不是**异常发生时的sp**，导致无法正确恢复！

**正确的方式（使用sscratch）：**

```
时间线：
t0: 异常发生，sp = 0xffffffffc0205000（原始栈指针）
    ↓
t1: csrw sscratch, sp
    sscratch = 0xffffffffc0205000（保存原始sp）
    sp = 0xffffffffc0205000（sp还没变）
    ↓
t2: addi sp, sp, -288
    sscratch = 0xffffffffc0205000（原始sp仍在sscratch中）
    sp = 0xffffffffc0204ee0（调整后的sp）
    ↓
t3: csrrw s0, sscratch, x0
    s0 = 0xffffffffc0205000（取回原始sp）
    sscratch = 0（清零）
    sp = 0xffffffffc0204ee0（仍然是调整后的sp）
    ↓
t4: STORE s0, 2*REGBYTES(sp)
    将原始sp保存到trapframe的正确位置
```

#### 1.4 sscratch寄存器的设计目的

**sscratch寄存器的特殊用途：**

1. **临时保存**：在不破坏其他寄存器的情况下保存一个值
2. **内核态标识**：
   - `sscratch = 0`：表示当前在内核态
   - `sscratch ≠ 0`：表示当前在用户态（通常保存用户栈指针）

3. **原子交换**：`csrrw`指令可以原子地完成读取和写入

**在uCore中的约定：**

```c
// 在idt_init()中设置
void idt_init(void) {
    extern void __alltraps(void);
    
    // 设置sscratch为0，表示当前在内核态
    write_csr(sscratch, 0);
    
    // 设置异常向量
    write_csr(stvec, &__alltraps);
}
```

**为什么清零sscratch？**
- 在内核态发生异常时，`sscratch = 0`
- 可以用来区分是从用户态还是内核态进入的异常
- 防止异常嵌套时使用错误的栈指针

#### 1.5 图解过程

```
异常发生前（在内核态执行）：
+------------------+
| 内核栈          |
| ...             |
| 局部变量        |
+------------------+ ← sp = 0xffffffffc0205000
                     sscratch = 0（在内核态）

↓ 异常发生

步骤1: csrw sscratch, sp
+------------------+
| 内核栈          |
+------------------+ ← sp = 0xffffffffc0205000
                     sscratch = 0xffffffffc0205000（保存原始sp）

步骤2: addi sp, sp, -288
+------------------+
| 内核栈          |
+------------------+   原始sp = 0xffffffffc0205000
| (空间，288字节) |
+------------------+ ← sp = 0xffffffffc0204ee0（新sp）
                     sscratch = 0xffffffffc0205000

步骤3: 保存寄存器到 [sp, sp+288)
+------------------+
| 内核栈          |
+------------------+   原始sp = 0xffffffffc0205000
| scause          | ← sp+280
| sbadaddr        | ← sp+272
| sepc            | ← sp+264
| sstatus         | ← sp+256
| x31-x3          |
| (原始sp)        | ← sp+16  将保存0xffffffffc0205000
| ra              | ← sp+8
| zero            | ← sp+0
+------------------+ ← sp = 0xffffffffc0204ee0
                     sscratch = 0（已清零）

步骤4: csrrw s0, sscratch, x0
    s0 = 0xffffffffc0205000（取回原始sp）
    sscratch = 0（清零）

步骤5: STORE s0, 2*REGBYTES(sp)
    将原始sp（0xffffffffc0205000）保存到trapframe中
```

---

### 二、为什么SAVE_ALL保存了stval/scause等CSR，而RESTORE_ALL不恢复它们？

#### 2.1 快速答案

**因为这些CSR寄存器是只读的或由硬件管理的，软件不能（也不需要）恢复它们。**

#### 2.2 详细分析

##### （1）CSR寄存器的分类

在SAVE_ALL中保存的CSR寄存器：

```asm
csrr s1, sstatus     // 读取sstatus
csrr s2, sepc        // 读取sepc
csrr s3, sbadaddr    // 读取sbadaddr（stval的旧称）
csrr s4, scause      // 读取scause

STORE s1, 32*REGBYTES(sp)   // 保存sstatus
STORE s2, 33*REGBYTES(sp)   // 保存sepc
STORE s3, 34*REGBYTES(sp)   // 保存sbadaddr
STORE s4, 35*REGBYTES(sp)   // 保存scause
```

**这些寄存器的性质：**

| 寄存器 | 是否可写 | 用途 | 是否需要恢复 |
|--------|---------|------|-------------|
| sstatus | 可写 | CPU状态（中断使能等） | **需要** |
| sepc | 可写 | 异常返回地址 | **需要** |
| sbadaddr/stval | **只读** | 异常地址（只能硬件写） | **不能** |
| scause | **只读** | 异常原因（只能硬件写） | **不能** |

##### （2）RESTORE_ALL只恢复必要的寄存器

```asm
.macro RESTORE_ALL
    // 只恢复sstatus和sepc
    LOAD s1, 32*REGBYTES(sp)    // 读取保存的sstatus
    LOAD s2, 33*REGBYTES(sp)    // 读取保存的sepc

    csrw sstatus, s1            // 恢复sstatus（可写）
    csrw sepc, s2               // 恢复sepc（可写）

    // 注意：不恢复sbadaddr和scause！

    // 恢复通用寄存器
    LOAD x1, 1*REGBYTES(sp)
    // ...
    LOAD x2, 2*REGBYTES(sp)
.endm
```

##### （3）为什么不恢复sbadaddr和scause？

**原因1：硬件限制 - 这些寄存器是只读的**

```asm
// 这些操作会失败或被忽略：
csrw sbadaddr, s3   // 错误！sbadaddr是只读的，只能硬件写入
csrw scause, s4     // 错误！scause是只读的，只能硬件写入
```

根据RISC-V特权架构规范：
- `sbadaddr`（或`stval`）：**只能由硬件在异常时写入**
- `scause`：**只能由硬件在异常时写入**
- 软件只有读权限，没有写权限

**原因2：语义上不需要恢复**

这些寄存器只在**异常处理期间**有意义：

```c
void exception_handler(struct trapframe *tf) {
    // 在这里，我们需要读取scause和sbadaddr：
    switch (tf->cause) {           // 读取scause
        case CAUSE_FAULT_LOAD:
            cprintf("Load fault at address: %p\n", 
                    tf->badvaddr);  // 读取sbadaddr
            break;
    }
}
// 异常处理完毕后返回，这些值不再需要
```

**返回时的状态：**
- 当sret执行后，CPU返回到正常执行
- `scause`和`sbadaddr`的值对恢复后的代码**没有意义**
- 下次异常发生时，硬件会自动更新这些值

**原因3：设计哲学 - 职责分离**

```
硬件职责：
- 产生异常时，写入scause、sepc、sbadaddr
- 执行sret时，从sepc恢复PC

软件职责：
- 保存这些值用于分析和处理
- 恢复执行状态（寄存器、栈）
- 不需要（也不能）写回这些只读寄存器
```

#### 2.3 那么保存它们的意义是什么？

**虽然不恢复，但保存它们非常重要！**

##### （1）异常分析和处理

```c
void trap(struct trapframe *tf) {
    // 根据保存的scause判断异常类型
    if ((intptr_t)tf->cause < 0) {
        // 中断处理
        switch (tf->cause) {
            case IRQ_S_TIMER:
                clock_set_next_event();
                break;
        }
    } else {
        // 异常处理
        switch (tf->cause) {
            case CAUSE_FAULT_LOAD:
                // 使用保存的sbadaddr定位缺页地址
                cprintf("Page fault at: %p\n", tf->badvaddr);
                handle_page_fault(tf->badvaddr);
                break;
        }
    }
}
```

##### （2）调试和错误报告

```c
void print_trapframe(struct trapframe *tf) {
    cprintf("trapframe at %p\n", tf);
    print_regs(&tf->gpr);
    cprintf("  status   0x%08x\n", tf->status);
    cprintf("  epc      0x%08x\n", tf->epc);
    cprintf("  badvaddr 0x%08x\n", tf->badvaddr);  // 显示异常地址
    cprintf("  cause    0x%08x\n", tf->cause);     // 显示异常原因
}
```

##### （3）复杂的异常处理逻辑

```c
void exception_handler(struct trapframe *tf) {
    switch (tf->cause) {
        case CAUSE_FAULT_LOAD:
        case CAUSE_FAULT_STORE:
            // 检查是否是合法的用户地址访问
            if (tf->badvaddr >= USER_BASE && tf->badvaddr < USER_TOP) {
                // 合法的用户空间访问，可能是缺页，需要分配页面
                handle_page_fault(tf->badvaddr, tf->cause);
            } else {
                // 非法地址访问
                panic("Invalid memory access at %p", tf->badvaddr);
            }
            break;
            
        case CAUSE_BREAKPOINT:
            // 断点异常，修改epc跳过断点指令
            cprintf("Breakpoint at %p\n", tf->epc);
            tf->epc += 2;  // ebreak是2字节指令
            break;
    }
}
```

##### （4）系统调用参数传递

```c
void syscall_handler(struct trapframe *tf) {
    // 检查确实是系统调用
    if (tf->cause != CAUSE_USER_ECALL) {
        return;
    }
    
    // 从trapframe读取系统调用号和参数
    int syscall_no = tf->gpr.a7;
    long arg0 = tf->gpr.a0;
    long arg1 = tf->gpr.a1;
    
    // 执行系统调用...
    long ret = do_syscall(syscall_no, arg0, arg1, ...);
    
    // 设置返回值
    tf->gpr.a0 = ret;
    
    // 修改epc，跳过ecall指令
    tf->epc += 4;
}
```

#### 2.4 完整的生命周期

```
异常发生：
    硬件写入: scause = 0x8000000000000005（时钟中断）
              sbadaddr = 0（不适用）
              sepc = 0xffffffffc0201234（异常发生的PC）
    ↓
SAVE_ALL：
    保存到栈: tf->cause = 0x8000000000000005
             tf->badvaddr = 0
             tf->epc = 0xffffffffc0201234
    ↓
trap()处理：
    读取: switch (tf->cause) { ... }
    使用: 分析异常类型，执行对应处理
    可能修改: tf->epc += 4（跳过某条指令）
    ↓
RESTORE_ALL：
    恢复sstatus: csrw sstatus, s1
    恢复sepc: csrw sepc, s2
    不恢复cause和badvaddr（不需要，也不能）
    ↓
sret：
    硬件操作: PC ← sepc（返回到异常点或修改后的地址）
             恢复特权级和中断状态
    ↓
继续执行：
    cause和badvaddr对恢复后的代码没有意义
    下次异常时，硬件会重新写入这些寄存器
```

#### 2.5 总结对比表

| 操作 | sstatus | sepc | sbadaddr | scause |
|------|---------|------|----------|--------|
| **SAVE_ALL保存** | ✓ | ✓ | ✓ | ✓ |
| **trap()中读取** | 可能 | 可能 | ✓ | ✓ |
| **trap()中修改** | 可能 | 常见 | 不修改 | 不修改 |
| **RESTORE_ALL恢复** | ✓ | ✓ | ✗ | ✗ |
| **恢复的原因** | 控制中断状态 | 控制返回地址 | - | - |
| **不恢复的原因** | - | - | 硬件只读 | 硬件只读 |

---

## 三、综合总结

### 3.1 中断处理的完整流程

```
[1] 异常产生（硬件）
    → 保存sepc、scause、sbadaddr到CSR
    → 跳转到stvec(__alltraps)

[2] SAVE_ALL（软件-汇编）
    → csrw sscratch, sp（保存原始sp）
    → 分配栈空间
    → 保存所有通用寄存器
    → csrrw s0, sscratch, x0（取回原始sp并清零sscratch）
    → 保存CSR寄存器（包括原始sp）

[3] trap()处理（软件-C）
    → move a0, sp（传递trapframe指针）
    → 分析cause，分发到对应处理函数
    → 可能修改trapframe（如修改epc）

[4] RESTORE_ALL（软件-汇编）
    → 恢复sstatus和sepc（可写的CSR）
    → 恢复所有通用寄存器
    → 不恢复scause和sbadaddr（只读，不需要）

[5] sret返回（硬件）
    → PC ← sepc
    → 恢复特权级和中断状态
```

### 3.2 关键设计要点

1. **sscratch的妙用**：
   - 作为临时寄存器保存原始sp
   - 标识内核态/用户态（0/非0）
   - 支持原子的读写交换操作

2. **trapframe的设计**：
   - 汇编与C结构体完全对应
   - 通过REGBYTES适配不同架构
   - 保存完整上下文用于分析和恢复

3. **寄存器分类处理**：
   - 通用寄存器：全部保存和恢复
   - 可写CSR（sstatus、sepc）：保存和恢复
   - 只读CSR（scause、sbadaddr）：只保存不恢复

4. **透明性原则**：
   - 保存所有寄存器确保透明性
   - 中断处理对被中断代码完全透明
   - 支持任意复杂的C函数调用

### 3.3 与其他架构的对比

| 特性 | RISC-V | x86 | ARM |
|------|--------|-----|-----|
| 硬件保存的寄存器 | 3个CSR | 部分（ss、esp、eflags、cs、eip） | 部分 |
| 需要软件保存 | 32个通用寄存器 | 其余通用寄存器 | 其余通用寄存器 |
| 异常向量 | stvec单一入口 | IDT多入口 | 向量表 |
| 返回指令 | sret | iret | eret |

**RISC-V的特点：**
- 硬件做得少，软件做得多（RISC哲学）
- 提供灵活性（sscratch等辅助寄存器）
- 简化硬件，但需要更多软件支持

---

## 四、实践建议

### 4.1 调试技巧

1. **打印trapframe**：
```c
void trap(struct trapframe *tf) {
    cprintf("=== Trap Entry ===\n");
    print_trapframe(tf);
    trap_dispatch(tf);
    cprintf("=== Trap Exit ===\n");
}
```

2. **检查栈完整性**：
```c
void check_stack(struct trapframe *tf) {
    if (tf->gpr.sp < KERNBASE || tf->gpr.sp >= KERNTOP) {
        panic("Stack overflow detected!");
    }
}
```

3. **统计中断**：
```c
static int trap_count[16] = {0};
void trap_dispatch(struct trapframe *tf) {
    intptr_t cause = (tf->cause << 1) >> 1;
    trap_count[cause]++;
    // ...
}
```

### 4.2 常见错误

1. **忘记设置下次时钟中断**：
```c
case IRQ_S_TIMER:
    // 错误：忘记调用clock_set_next_event()
    // 结果：只会触发一次时钟中断
    
    // 正确：
    clock_set_next_event();  // 必须调用！
    break;
```

2. **修改epc时字节数错误**：
```c
case CAUSE_BREAKPOINT:
    tf->epc += 2;  // ebreak是2字节压缩指令
    break;
    
case CAUSE_ILLEGAL_INSTRUCTION:
    tf->epc += 4;  // 大多数RISC-V指令是4字节
    break;
```

3. **栈对齐问题**：
```asm
// RISC-V要求栈16字节对齐
addi sp, sp, -36 * REGBYTES  // 288字节，是16的倍数，正确
```

---

## 五、参考资料

1. **RISC-V特权架构规范**（Privileged Architecture Specification）
   - CSR寄存器定义
   - 异常处理机制
   - sret指令行为

2. **uCore实验指导书**
   - Lab3中断与异常处理
   - trapframe结构设计

3. **相关代码文件**
   - `kern/trap/trapentry.S`：异常入口和上下文切换
   - `kern/trap/trap.c`：异常分发和处理
   - `kern/trap/trap.h`：trapframe结构定义
   - `libs/riscv.h`：RISC-V相关宏定义

---

**报告完成时间：** 2025年10月30日

**实验环境：**
- 操作系统：Linux
- 架构：RISC-V 64位
- 仿真器：QEMU-system-riscv64
