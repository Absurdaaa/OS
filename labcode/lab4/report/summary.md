# Lab4 实验总结

## 一、本实验的要点及其与操作系统原理的对应

### 1. 进程控制块（PCB）的设计与实现

实验内容：

- `struct proc_struct` 的字段设计
- 包含 `state`、`pid`、`kstack`、`context`、`trapframe`、`mm`、`pgdir` 等
- 使用 `kmalloc` 在内核堆分配进程结构和栈

原理对应：

- PCB（Process Control Block）记录进程状态和资源
- 进程由程序、执行状态与资源共同构成

说明：PCB 是进程管理的核心。实验中 `proc_struct` 将理论中的抽象落到具体数据结构上，需考虑内存布局和对齐，且实验对一些复杂字段（如文件表、信号）作了简化。

### 2. 进程状态转换与调度

实验内容：

- 状态集合：`PROC_UNINIT`、`PROC_RUNNABLE`、`PROC_SLEEPING`、`PROC_ZOMBIE`
- 关键函数：`wakeup_proc`、`proc_run`
- 调度方式：遍历 `proc_list` 选择可运行进程

原理对应：

- 五状态模型（新建、就绪、运行、阻塞、终止）和常见调度算法（FCFS、优先级、时间片轮转）

说明：实验把模型简化为四状态并用线性扫描实现调度，重点在于实现机制而非性能优化，后续可扩展优先级或时间片调度。

### 3. 上下文切换（Context Switch）

实验内容：

- `struct context` 保存被调用者要保存的寄存器（ra、sp、s0-s11）
- `switch_to` 汇编完成寄存器保存/恢复
- `proc_run` 先切页表再切上下文

原理对应：

- 切换步骤包括保存现场、选择进程、恢复现场；上下文含寄存器、PC、栈指针和页表基址等

说明：实验区分了 `context`（用于切换）和 `trapframe`（用于中断返回），并依赖 RISC-V 的调用约定完成寄存器管理。

### 4. 进程创建（fork）

实验内容：

- `do_fork` 分配 PCB、内核栈并设置 `trapframe`、`context`
- `copy_thread` 设置子进程的初始返回值和执行环境
- 通过寄存器区分父子返回值

原理对应：

- `fork` 创建进程副本，通常结合写时复制（COW）以节省开销

说明：本次实现主要针对内核线程（共享地址空间），`copy_mm` 未实现用户空间复制，真正的用户级 `fork` 与 COW 需在后续扩展中实现。

### 5. 虚拟内存与分页机制

实验内容：

- Sv39 三级页表的索引与偏移
- `get_pte` 按需分配中间页表
- 页表项标志位（V、R、W、X、U、A、D）以及地址转换宏如 `KADDR`、`PADDR`

原理对应：

- 虚拟内存提供地址隔离与按需分页，多级页表减少占用，TLB 用于加速转换

说明：实验展示了页表查找与创建的具体实现，需动手处理位域与索引，体现了 RISC-V 的页表格式细节。

### 6. 临界区保护与中断管理

实验内容：

- `local_intr_save/restore` 通过读写 `sstatus` 的 SIE 位实现关中断
- 保存原始中断状态以支持嵌套保护

原理对应：

- 临界区的互斥访问、同步原语（锁、信号量等）以及最低层的关中断机制

说明：关中断是内核中最直接的同步手段，适用于单核环境；多核需使用更细粒度的同步（如自旋锁）。

### 7. 内核栈与用户栈

实验内容：

- 每个进程分配独立内核栈（`setup_kstack`）用于保存 `trapframe` 与内核调用链
- `proc->tf` 指向栈顶的 `trapframe`

原理对应：

- 用户栈与内核栈分属不同特权级，切换时需更换栈指针以保护内核内存

说明：本次实验主要为内核线程分配内核栈，用户态相关内容将在后续实验中补充。

### 8. 进程标识符（PID）管理

实验内容：

- `get_pid` 遍历 `proc_list` 确保 PID 唯一，使用 `last_pid` 和 `next_safe` 优化查找
- 支持 PID 回收但避免与现存进程冲突

原理对应：

- PID 是进程的唯一标识，管理方式包括分配与回收

说明：实现采用简洁的线性分配与回收策略，生产系统可能会用位图或更高效的数据结构。

---

## 二、原理中重要但本实验未覆盖的内容

### 1. 进程间通信（IPC）

要点：管道、消息队列、共享内存、套接字等是进程协同的基础。本实验聚焦进程创建与调度，IPC 需要更复杂的缓冲与同步支持，通常在后续扩展中实现。

### 2. 优先级与多级反馈队列调度

要点：优先级调度和多级反馈队列用于平衡不同类型负载。当前调度器实现简单，后续可添加优先级字段和队列结构。

### 3. 多核（SMP）支持

要点：多核需考虑负载均衡、锁扩展和缓存一致性。实验在单核环境下简化了这些问题。

### 4. 实时调度

要点：实时系统对时延有严格要求，需要特定的调度策略和精确时钟管理，超出了本课程基础实验范围。

### 5. 线程与轻量级进程

要点：线程模型可以在用户态或内核态实现，本实验以内核线程为主，用户级线程与线程库实现待后续补充。

### 6. 写时复制（COW）

要点：COW 是 fork 优化的常用方式，需配合页错误处理与内存管理实现，当前实验未实现 `copy_mm`。

### 7. 信号机制

要点：信号用于异步通知，涉及信号栈和掩码管理，属于更高层的内核功能。

### 8. 进程组与会话

要点：进程组和会话用于作业控制与终端管理，本实验没有实现 shell 与终端支持。

### 9. 守护进程（Daemon）

要点：守护进程是后台服务的一种实现方式，更多出现在系统编程层面。

### 10. 资源限制（ulimit）

要点：系统需限制各进程资源以保证稳定性，本实验暂未实现资源统计与限制功能。

---

## 三、实验感想

### 1. 理论与实现的差距

通过动手实现发现，理论给出的是抽象模型，而实现需要处理大量细节：位域、寄存器保存顺序、内存对齐等，且实现常依赖具体硬件（本实验以 RISC-V 为例）。

### 2. 取舍与学习路径

uCore 在保留核心机制的同时对非核心部分做了简化，方便循序渐进地学习内核机制，从内核线程到用户进程逐步扩展。

### 3. 代码质量与鲁棒性

良好的错误处理、正确的同步以及清晰注释对内核代码尤为重要，能显著降低调试难度并防止资源泄漏。

### 4. 调试方法

常用手段包括 GDB + QEMU 单步调试、在关键路径打印信息以及用断言检查不变量。

### 5. 设计中的层次与重复性

多级页表、进程树和嵌套临界区等结构体现了重复性与层次化思路，既便于设计也增加理解成本。

---

## 四、后续改进方向

1. 实现优先级调度并支持动态调整
2. 完善用户进程支持（实现 `copy_mm`、用户态 fork/exec）
3. 增加同步原语（信号量、互斥锁、条件变量）
4. 优化性能（进程查找、TLB 管理、页表遍历）
5. 强化错误处理与日志机制

---

## 五、结语

本次实验实现了进程管理的基本功能，使我更清楚地了解了进程的构成、调度流程和虚拟内存的实现要点。理论给出方向，实践回答细节；动手完成这些模块，有助于后续学习文件系统、设备驱动与并发控制等更复杂的内核内容。

本实验为继续深入操作系统打下了坚实基础。
