# 实验报告：观察 `ecall` 和 `sret` 指令在 QEMU 中的处理流程

## 一、实验目的

1. 理解 RISC-V 特权指令 `ecall`（环境调用）和 `sret`（特权返回）的执行机制。
2. 学习 QEMU 对这些指令的处理流程，包括 TCG 翻译和 trap/异常处理。
3. 熟悉在 GDB 下单步调试内核和系统调用的技巧。

---

## 二、实验环境

* 操作系统：Ubuntu 22.04
* 仿真器：QEMU 6.2.0
* 编译工具链：riscv64-unknown-elf-gcc
* 调试工具：riscv64-unknown-elf-gdb（SiFive GDB-Metal 10.1）

---

## 三、实验过程

### 1. 双重gdb调试

我们首先在一个终端中输入指令make debug，然后新建一个终端在终端中输入指令make gdb，然后在gdb中添加用户程序符号文件：

```gdb
add-symbol-file obj/__user_exit.out
```

设置断点：

* 内核 trap 入口 `trapentry.S`
* 用户系统调用函数 `syscall.c`

```gdb
b kern/trap/trapentry.S:133
b user/libs/syscall.c:18
```

---

### 2. 调试 `ecall` 指令

1. 单步执行到用户程序的 `syscall` 调用：

   ```gdb
   si
   ```
2. 当 PC 指向 `ecall` 指令时：

   ```gdb
   0x80008e <syscall+44>: ecall
   ```

   QEMU 会触发 trap，将控制权切换到内核异常处理入口 `__alltraps()`。
3. `__alltraps()` 的执行流程：

   * 调用 `SAVE_ALL` 保存所有通用寄存器和特权寄存器：

     ```asm
        0xffffffffc0200f18 <__alltraps+12>:  addi    sp,sp,-288
        0xffffffffc0200f1a <__alltraps+14>:  sd      zero,0(sp)
        0xffffffffc0200f1c <__alltraps+16>:  sd      ra,8(sp)
        0xffffffffc0200f1e <__alltraps+18>:  sd      gp,24(sp)
        0xffffffffc0200f20 <__alltraps+20>:  sd      tp,32(sp)
        0xffffffffc0200f22 <__alltraps+22>:  sd      t0,40(sp)
        0xffffffffc0200f24 <__alltraps+24>:  sd      t1,48(sp)
        0xffffffffc0200f26 <__alltraps+26>:  sd      t2,56(sp)
        0xffffffffc0200f28 <__alltraps+28>:  sd      s0,64(sp)
        0xffffffffc0200f2a <__alltraps+30>:  sd      s1,72(sp)
        0xffffffffc0200f2c <__alltraps+32>:  sd      a0,80(sp)
        0xffffffffc0200f2e <__alltraps+34>:  sd      a1,88(sp)
        0xffffffffc0200f30 <__alltraps+36>:  sd      a2,96(sp)
        0xffffffffc0200f32 <__alltraps+38>:  sd      a3,104(sp)
        0xffffffffc0200f34 <__alltraps+40>:  sd      a4,112(sp)
        0xffffffffc0200f36 <__alltraps+42>:  sd      a5,120(sp)
        0xffffffffc0200f38 <__alltraps+44>:  sd      a6,128(sp)
        0xffffffffc0200f3a <__alltraps+46>:  sd      a7,136(sp)
        0xffffffffc0200f3c <__alltraps+48>:  sd      s2,144(sp)
        0xffffffffc0200f3e <__alltraps+50>:  sd      s3,152(sp)
        0xffffffffc0200f40 <__alltraps+52>:  sd      s4,160(sp)
        0xffffffffc0200f42 <__alltraps+54>:  sd      s5,168(sp)
        0xffffffffc0200f44 <__alltraps+56>:  sd      s6,176(sp)
        0xffffffffc0200f46 <__alltraps+58>:  sd      s7,184(sp)
        0xffffffffc0200f48 <__alltraps+60>:  sd      s8,192(sp)
        0xffffffffc0200f4a <__alltraps+62>:  sd      s9,200(sp)
        0xffffffffc0200f4c <__alltraps+64>:  sd      s10,208(sp)
        0xffffffffc0200f4e <__alltraps+66>:  sd      s11,216(sp)
        0xffffffffc0200f50 <__alltraps+68>:  sd      t3,224(sp)
        0xffffffffc0200f52 <__alltraps+70>:  sd      t4,232(sp)
        0xffffffffc0200f54 <__alltraps+72>:  sd      t5,240(sp)
        0xffffffffc0200f56 <__alltraps+74>:  sd      t6,248(sp)
        0xffffffffc0200f58 <__alltraps+76>:  csrrw   s0,sscratch,zero
        0xffffffffc0200f5c <__alltraps+80>:  csrr    s1,sstatus
        0xffffffffc0200f60 <__alltraps+84>:  csrr    s2,sepc
        0xffffffffc0200f64 <__alltraps+88>:  csrr    s3,stval
        0xffffffffc0200f68 <__alltraps+92>:  csrr    s4,scause
        0xffffffffc0200f6c <__alltraps+96>:  sd      s0,16(sp)
        0xffffffffc0200f6e <__alltraps+98>:  sd      s1,256(sp)
        0xffffffffc0200f70 <__alltraps+100>: sd      s2,264(sp)
        0xffffffffc0200f72 <__alltraps+102>: sd      s3,272(sp)
        0xffffffffc0200f74 <__alltraps+104>: sd      s4,280(sp)
     ```
   * 将 trap frame 地址传递给 `trap()` 函数：

     ```asm
        0xffffffffc0200f76 <__alltraps+106>: mv      a0,sp
        0xffffffffc0200f78 <__alltraps+108>: jal     ra,0xffffffffc0200e80 <trap>
     ```
4. 内核 `trap()` 处理：

   * 调用 `trap_dispatch(tf)` 分发异常类型。
   * 对 `ecall`，最终调用 `syscall()` 处理具体系统调用。

> **说明**：此过程展示了 QEMU 对 `ecall` 的关键处理——TCG 将 guest `ecall` 指令翻译为 host 代码块，触发 QEMU 内部 trap，然后进入内核处理。

---

### 3. 调试 `sret` 指令

1. 在内核处理完系统调用后，使用 `sret` 返回用户态：

   ```asm
   __trapret:
       ld s1, 256(sp)
       ld s2, 264(sp)
       ...
       sret
   ```
2. `sret` 会：

   * 恢复之前保存的特权寄存器状态（`sstatus`, `sepc`, `sscratch` 等）。
   * 切换回用户态 PC（`sepc`）。
   * 恢复寄存器值，实现上下文切换。
3. 单步观察到：

   * `__trapret` 恢复寄存器：

     ```asm
     ld ra, 8(sp)
     ld t0, 40(sp)
     ...
     csrw sstatus, s1
     csrw sepc, s2
     ```
   * 返回用户程序继续执行。

> **说明**：`sret` 的作用是完成特权返回，恢复用户态上下文，同时寄存器恢复确保系统调用后用户程序状态保持一致。

---

### 4. QEMU 处理机制分析

1. **TCG 指令翻译**：

   * QEMU 并不直接执行 guest 指令，而是动态将 guest 指令翻译为 host 指令块。
   * `ecall` / `sret` 会被翻译成 host 代码块，并在 host 上触发 trap/异常回调。
2. **Trap 处理流程**：

   ```
   Guest ecall -> TCG block -> host trap callback -> __alltraps() -> trap() -> trap_dispatch() -> syscall()
   ```
3. **寄存器保存与恢复**：

   * 内核通过 `SAVE_ALL` 保存通用寄存器。
   * 通过 `__trapret` 和 `sret` 恢复寄存器，实现从内核态返回用户态。

---

## 五、调试过程中观察到的寄存器变化

* `current->tf` 中记录了 trap frame：

  ```
  a0 = 30 (syscall号)
  a1 = 109
  sp = 0x7ffffe50
  pc = 0x800082 (syscall)
  status = 0x8020...
  ```
* `SAVE_ALL` 将 ra、t0-t6、s0-s11、a0-a7、sstatus、sepc、stval、scause 等寄存器保存到内核栈。
* `sret` 恢复时，将这些寄存器重新加载，实现用户态返回。

---

## 六、实验结论

1. `ecall` 指令在 QEMU 中触发 trap，由内核 `trap()` 和 `syscall()` 处理，整个过程通过 TCG 翻译实现 host 执行。
2. `sret` 指令完成从内核态返回用户态的上下文切换，恢复所有寄存器和特权状态。