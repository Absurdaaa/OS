# 操作系统实验2：物理内存管理

## 1 练习1：理解first-fit 连续物理内存分配算法

### 1.1 算法概述

First-Fit（首次适应）算法是一种连续内存分配策略，当收到内存分配请求时，从空闲内存块链表的起始位置开始搜索，选择第一个能够满足请求大小的空闲块进行分配。如果选中的空闲块大小明显大于请求大小，则将其分割为两部分：一部分分配给请求者，剩余部分作为新的空闲块。

通过分析`kern/mm/default_pmm.c`中的源码实现，可以深入理解First-Fit算法的工作机制和实现细节。

### 1.2 数据结构分析

页面描述符结构体Page定义在`memlayout.h:34-39`：
```c
struct Page {
    int ref;                        // 页面引用计数器
    uint64_t flags;                 // 页面状态标志位
    unsigned int property;          // 空闲块大小（仅对空闲块首页有效）
    list_entry_t page_link;         // 双向链表节点
};
```

空闲区域管理结构体free_area_t定义在`memlayout.h:58-61`：
```c
typedef struct {
    list_entry_t free_list;         // 空闲块链表头
    unsigned int nr_free;           // 空闲页面总数
} free_area_t;
```

### 1.3 核心函数实现分析

#### 1.3.1 default_init函数

位置：`default_pmm.c:131-134`

该函数负责初始化内存管理器的全局状态。通过调用`list_init(&free_list)`初始化空闲块双向链表，并将空闲页面计数器`nr_free`置零，为后续的内存分配和释放操作建立初始状态。

#### 1.3.2 default_init_memmap函数

位置：`default_pmm.c:140-165`

该函数初始化一段连续的物理内存空间，将其纳入内存管理器的管辖范围。具体实现过程首先进行页面状态初始化，遍历从`base`开始的`n`个页面，清除所有页面的标志位和引用计数。然后进行空闲块属性设置，设置块首页的`property`字段为块大小`n`，并设置`PG_property`标志位。接下来进行链表插入，按地址升序将空闲块插入到`free_list`中，保持链表的地址有序性。最后进行计数器更新，更新全局空闲页面计数`nr_free += n`。

该函数在系统启动时被调用，用于建立初始的空闲内存池。

#### 1.3.3 default_alloc_pages函数

位置：`default_pmm.c:168-195`

该函数分配`n`个连续的物理页面，是First-Fit算法的核心实现。实现过程首先进行可行性检查，验证`n > nr_free`条件，如果空闲页面不足则直接返回NULL。接着进行空闲块搜索，从链表头开始遍历，寻找第一个满足`p->property >= n`的空闲块。如果找到的空闲块大小大于请求大小，则进行块分割处理，计算剩余部分起始地址为`struct Page *p = page + n`，设置剩余块的属性为`p->property = page->property - n`，并将剩余块重新插入链表。随后进行状态更新，清除已分配页面的`PG_property`标志，更新空闲页面计数。最后返回分配的页面起始地址。

该函数体现了First-Fit算法的核心思想：总是选择第一个满足条件的空闲块进行分配。

#### 1.3.4 default_free_pages函数

位置：`default_pmm.c:198-245`

该函数释放`n`个连续的物理页面。实现过程首先进行页面状态重置，清除释放页面的所有标志位，重置引用计数。然后进行空闲块设置，设置释放块首页的`property`为`n`，设置`PG_property`标志。接下来进行有序插入，按地址升序将释放块插入到空闲链表中。随后进行相邻块合并，检查并合并地址连续的相邻空闲块，包括前向合并检查前一个块是否与当前块地址连续，以及后向合并检查后一个块是否与当前块地址连续。最后进行计数器更新，更新全局空闲页面计数。

合并策略通过检查前一个和后一个块是否与当前块地址连续，如果连续则合并，有效减少了外部碎片。

### 1.4 物理内存分配过程

整个物理内存分配过程包括初始化阶段、分配阶段、释放阶段和碎片管理四个主要阶段。在初始化阶段，系统启动时通过`default_init_memmap`将所有可用物理内存组织成空闲块链表。在分配阶段，当需要分配内存时，`default_alloc_pages`从链表头开始遍历，找到第一个足够大的空闲块进行分配。在释放阶段，当释放内存时，`default_free_pages`将释放的块插入链表，并尝试与相邻块合并。在碎片管理阶段，通过合并相邻的空闲块来减少外部碎片，提高内存利用率。

### 1.5 算法特点分析

First-Fit算法具有实现简单、分配速度快和内存开销小的优点。该算法逻辑直观，易于理解和维护，平均情况下分配速度较快，无需遍历整个链表，且不需要额外的数据结构维护空闲块信息。然而，First-Fit算法也存在一些缺点，可能会产生大量小的外部碎片，大块内存可能被分割导致后续无法满足大内存请求，内存利用率不是最优的。

时间复杂度方面，分配操作为O(n)，其中n为空闲块数量，最坏情况下需要遍历整个空闲链表；释放操作也为O(n)，需要找到合适的插入位置并进行可能的合并操作。空间复杂度为O(1)，仅需维护链表结构和计数器，空间开销恒定。

## 2 练习2：实现 Best-Fit 连续物理内存分配算法

### 2.1 算法设计原理

Best-Fit（最佳适应）算法是对First-Fit算法的改进，其核心思想是在所有满足分配条件的空闲块中，选择大小最接近请求大小的块进行分配。这种策略旨在减少大块内存被分割的可能性，从而降低外部碎片的产生。

### 2.2 实现方案

基于对First-Fit算法的分析，我设计实现了Best-Fit分配算法。该算法复用了First-Fit的数据结构和大部分辅助函数，仅修改了内存分配策略。

### 2.3 核心实现

Best-Fit算法的核心修改在于内存分配函数，需要遍历整个空闲链表以找到最优的空闲块：

```c
static struct Page *
best_fit_alloc_pages(size_t n) {
    assert(n > 0);
    if (n > nr_free) {
        return NULL;
    }

    struct Page *best_page = NULL;
    size_t min_size = SIZE_MAX;
    list_entry_t *le = &free_list;

    // 遍历整个空闲链表，寻找最小的满足条件的块
    while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n && p->property < min_size) {
            min_size = p->property;
            best_page = p;
            // 如果找到大小正好匹配的块，直接选择
            if (p->property == n) {
                break;
            }
        }
    }

    if (best_page != NULL) {
        list_entry_t* prev = list_prev(&(best_page->page_link));
        list_del(&(best_page->page_link));

        // 如果块大小大于请求大小，进行分割
        if (best_page->property > n) {
            struct Page *p = best_page + n;
            p->property = best_page->property - n;
            SetPageProperty(p);
            list_add(prev, &(p->page_link));
        }

        nr_free -= n;
        ClearPageProperty(best_page);
    }

    return best_page;
}
```

### 2.4 实现特点

#### 2.4.1 核心改进点

Best-Fit算法的核心改进点包括全局搜索策略、最小块选择和提前终止优化。与First-Fit不同，Best-Fit需要遍历整个空闲链表以确保找到最优块。算法维护`min_size`变量记录当前找到的最小满足条件的块，并且在找到大小正好匹配的块时可以提前终止搜索。

#### 2.4.2 兼容性设计

在兼容性设计方面，Best-Fit算法的释放操作完全复用First-Fit的实现，数据结构和初始化过程保持不变，仅修改分配策略，确保系统的稳定性。

### 2.5 算法复杂度分析

时间复杂度方面，分配操作为O(n)，其中n为空闲块数量，必须遍历整个空闲链表；释放操作为O(n)，与First-Fit算法相同。空间复杂度为O(1)，与First-Fit算法相同。

### 2.6 算法特点分析

Best-Fit算法具有减少外部碎片、提高内存利用率和保留大块内存的优点。该算法选择最小的满足条件的块，减少大块内存的分割，长期运行下能够更好地利用内存资源，并为后续的大内存请求保留更大的空闲块。然而，Best-Fit算法也存在一些缺点，分配速度较慢，必须遍历整个空闲链表，时间开销较大，长期运行可能产生大量小的、难以利用的碎片，实现复杂度略高，相比First-Fit需要额外的比较和选择逻辑。

## 3 总结

通过本实验，我深入分析了ucore操作系统中的First-Fit连续物理内存分配算法，理解了物理内存管理的核心机制。在此基础上，设计实现了Best-Fit算法，并通过对比分析阐明了两种算法的适用场景和性能特点。

First-Fit算法适合对分配速度要求较高、内存请求大小差异较大的场景；而Best-Fit算法更适合对内存利用率要求较高、内存请求大小相对均匀的场景。两种算法各有优缺点，实际系统中的内存管理器往往需要根据具体的应用场景和性能需求进行权衡和选择。

通过本实验，我不仅掌握了连续内存分配算法的实现原理，还深入理解了操作系统内存管理的复杂性和重要性，为后续学习更复杂的内存管理机制奠定了基础。